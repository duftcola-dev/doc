DOCKER USER MANUAL

#Basic commands

	
	docker ps  **current running container
	docker ps -a **previously run images
	docker start **starts container
	docker stop **stop container
	docker restart **restart contianer
	docker logs <container_id> ** just the cointainer logs
	docker tag <image_name> <new_tag>/<image_name>
	docker rmi <image_id> ** removes and image
	docker rm <container_id> ** removes container
	docker exec -it <container_id> ** allows to get inside the container files

----------------------------------------------------------------------------------	

#Download docker image : 

 	docker pull <image_name>

---------------------------------------------------------------------------------------

#Create docker images

** Docker files are blueprints for creating images or "recipes". This images created by docker files
can be used in a docker compose just like the stadard ones.
** Docker files are just files named : Dockerfile
	

	FROM <image_name>	
	ENV <set_enviroment_variables>  
	RUN mkdir -p /home/app  
	COPY . /home/app   
	CMD ["run_command_for_image" , "/home/app/entry_point_file"] 

	** FROM <image_name> : Set_enviroment_variables (optional).It is advicesable to leave ENV to compose files
	**RUN mkdir -p /home/app : Creates a directory inside the container as entry point for the app
	**COPY . /home/app : Copies the local files of the host machine int /app inside the container
	**CMD :Execution commands . Notice these strings require ""

Example : 

    FROM python:3.9.9-bullseye

    WORKDIR /.

    COPY requirements.txt requirements.txt

    RUN pip install -r requirements.txt --upgrade pip

    COPY . .

    EXPOSE 5000
    
    ENTRYPOINT [ "python" ]

    CMD ["app_flask.py"]

---------------------------------------------------------------------------------------------	
	
#Build docker file :

	docker build -t <docker_image_name:version> <path_to_docker_file>
	
	**<docker_image_name:version> : How would you like to name your image
	**<path_to_docker_file> : path to the docker file . Use "." if it is in the current dir
	
How to retag/tag a dockerfile :

	docker tag <image_name> <new_tag>/<image_name>

---------------------------------------------------------------------------------------------

#Run docker container:


	 docker run -d -p<host_port>:<container_port> --name <custom_name> --net <network_name> image_name
	 
	 ***** Notice not all this parameters are necessary for a simple build
	 **-p : binding of the host machine port and the container internal port.
	 **-d : run in detach mode.
	 ** --name : renames the container with the specified name
	 **--net : selects to run this container in a specific network.

---------------------------------------------------------------------------------------------

#Interact with the environment files of the container: 

	docker exec -it <container_id> /bin/bash

	or 

	docker exec -it <container_name> <console_command>

	example:

		-docker exec -it redis_service redis-cli 
	
	**once inside the contianer inv you can use bash commands as usual like pwd ,ls , cd etc
	**env prints the environment variables

---------------------------------------------------------------------------------------------

#Create containers network

How to connect container and create a network of containers :
Example ( connect a flask container with a database container)

	docker network ls **Check the newtworks generated by docker by default
	docker network create <network-name>

---------------------------------------------------------------------------------------------

#Creating docker compose using docker yaml

** Docker compose is just a file to contain docker commands
**When Creating a Docker compose file no it is no necessary to create a network since the docker compose file does
it for you.
Example of a .yaml file for Postgresql:


version: '3.1'

services:

  db:
    image: postgres
    user : root
    restart: always
    ports:
    	- 8080:8080
    environment:
      POSTGRES_PASSWORD: some_passwords_service
     
    networks:
        - network_name_for_thi
    volumes:
        - ./some_folder:/data/some_subfoolder
  adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080

**the tag user: root **gives you full access to your volumes,this is important to sae your volumes in git

Using the docker compose command : 

	docker-compose -f <file_in_app_folder.yaml> up ** This starts adn creates the containers in the compose file
	docker-compose -f <file_in_app_folder.yaml> down ** Stops all containers in the compose file

-------------------------------------------------------------------------------------------

#Data persistance with Docker volumes. 

** The main use of docker volumes is to have data persistance . That means all the infor in your container/s is copied into a local folder so it can be save every time the container/s are stoped and restarted.
So basically the path to a file/folder in our host machine is added to the container fro persintency .

There are 2 types of docker volumes :

	1) Host volume : the reference
	*During docker run command add the option -v <path_to_host_folder>:<path_to_container_folder> where data 		will stored . ** <path_to_host_folder>:<path_to_container_folder> should be the same.
	
	2) Volume defined in docker-compose
	volumes:
	    - <folder_name_for_volume>:/sub_folder

		or

		- .:/sub_folder  **in case you want to create the volumen in the current location
--------------------------------------------------------------------------------------------

#Create a .dockerignore file

	A .dockerignore file is a file that allow us to spedify rules on wich files 
	should be copied and build during the image building process thus they wont be
	packed and uploaded to  docker server.

	** files specified wont by copied during COPY . .
	** files specified wont be included during the build process 

	example of a .dockerignore :

		venv
		.coverage
		__pycache__
		**/__pycache__
		*.pyc

	**SINTAX :

		*/temp*  **exclude files/directories that start by temp
		temp?    **exclude files/direcoties that contain the word 'temp'
		**/*.pycache  **exclude all files that end with '.pycache'
		*.md   ** exclude files that en with .md
		!README.md **except this .md file
--------------------------------------------------------------------------------------------

#Creating a private repository for Docker in AWS ECR (elastic container registry)
	
	** ECR is a private docker repository
	** I has registry options
	** allows build and tag images
	
	1) Log in into AWS and search ECR 
	2) Create a repository AWS ECR
	3) Login from you local PC using the login command provided by AWS ECR 
	** You need to have AWS CLI installed and have credentials to do step 3)
	4) tag the created image with the tag provided by AWS ECR
	5 push image
	
Development server in AWS ECR 

	** update your .yaml compose file with the new created image
	
	
	version: '3.1'

	services:
	  my-app:             ** Your app is going to be pulled from AWS ECR so the aws tag is very important
	    image: <aws-image-tag>/app_name
	    ports:
	    	-3000:3000

	  db:  		** Notice the other images are still necessary since thy will be 
	    image: postgres	   pulled from docker hub as dependencies
	    restart: always
	    ports:
	    	- 8080:8080
	    environment:
	      POSTGRES_PASSWORD: some_password

	  adminer:
	    image: adminer
	    restart: always
	    ports:
	      - 8080:8080
	      
	      
	  ** to summarize , your app image is being pulled from AWS ECR while the other dependencies are pulled 		     from docker hub so it is very important to use the AWS-tags to the deployiment server can make the 
	     distinction between both.
	 	
	
