
## MYSQL USER MANUAL

# MYSQL LOCAL INSTALLATION (LINUX UBUNTU)

    # Installation 

        sudo apt update 
        sudo apt upgrade
        sudo at install mysql-server

        ** check the installation worked by 

        mysql-version

        ** output --> mysql VER 8.0.25 

    # Additional database security functionalities
    ** Once the basic mysql server is installed it is
    necessary to install additional security features 
    to create users and  manage permissions

    **First change the authentication parameters 
    for the root user 

        sudo mysql

        ALTER USER 'root'@'localhost' IDENTIFIED WITH 
        mysql_native_password by 'mynewpassword';

        **Where mynewpassword is the password the root user will use
    
    **Now proceed with the installation with the secure features

        sudo mysql_secure_installation

    **Proceed with installation steps

# ENTER MYSQL CLI

    ** -u stands for user , -p stands for requesting for password 
    mysql -u user_name -p 


# CHANGE PASSWORD POLICY RULES

    **in mysql cli
        SHOW VARIABLES LIKE 'validate_password%';
        SET GLOBAL validate_password.policy=LOW;
        SET GLOBAL validate_password.length=0;
        
    **These changes are not permant and are only meant to be used once
    ** Now you can create whatever user you want with any
    password

    ** To check the current list of users :
    SELECT user,host FROM mysql.user;
       
    
**We have 4 main categories of queries :

        DDL **data definision
            - CREATE
            - ALTER
            - DROP
            - TRUNCATE
        DML **data manipulation
            - SELECT
            - INSERT 
            - UPDATE 
            - DELETE
        DCL **data control
            - GRANT 
            - REVOKE 
        TCL **TRANSACTION CONTROL 
            - BEGIN 
            - COMMIT 
            - ROLLBACK 
            - SAVEPOINT


---------------------------------------------------------------------------------
DCL
---------------------------------------------------------------------------------


# ADDING NEW USERS

        CREATE USER 'new_user'@'localhost' IDENTIFIED BY 'password';

        or 

        ALTER USER 'user'@'localhost' IDENTIFIED BY 'new_password';
        FLUSH PRIVILEGES;  

    **show users 

        use mysql;
        select user , host from user;


# GRANTING ACCESS TO SCHEMA TO A USER

    **There are 2 main function for privileges :
        - GRANT
        - REVOKE

    
    sintaxis: **as root :

    GRANT [CREATE,SELECT,UPDATE,INSERT,DELETE]  ON SCHEMA schema_name TO user_name

    example grant privileges over a schema:

        GRANT CREATE,SELECT,UPDATE,INSERT,DELETE ON SCHEMA.* TO 'user'@'localhost'

        **or grant all privileges:

        GRANT ALL PRIVILEGES ON SCHEMA.* TO 'user'@'localhost'

        **To grant privileges only to an specific table in that schema use:

        GRANT ALL PRIVILEGES ON SCHEMA.table_name TO 'user'@'localhost'

    **revoking privileges 

        **revoking all privileges 
        
        REVOKE ALL , GRANT OPTION  FROM usuario@localhost

    **rename user 

        rename user user@localhost to another_user_name@localhost

    **delete user 

        drop user@localhost
        

#  GRANTING / REVOKING PRIVILEGES FROM workbench

    **as root --> Administration --> Users and privileges 
    **It is quite graphical and straight forward from here

# CREATING/IMPORTING A DATABASE

        CREATE DATABASE IF NOT EXISTS DB_database_name

        **to delete it 
        DROP database DB_employees
        or
        DROP database IF EXISTS DB_employees 

        ** select the created database
        use DB_employees

        **once selected a database
        use 'source' command to select a .sql to import a fully build database
        **This method is usefull to import large data volumes
        
        source  /home/dutfcola-dev/Downloads/employees-db/dbEmployees.sql

        **There is a second way of executing this option for creating a database.

            - create a schema in mysql (from workbench or terminal)
            - now from outside of the cli execute :

                mysql -u root -p schema_created < url_to_file.sql


# CREATING  A DATABASE THAT ALLOWS ADDITIONAL / SPECIAL CHARACTERS

    **Show the available character sets in the current version of SQL 
    **It is better to this in workbench

        show char set

    **Show the characters set curently being used by the server 

        show variables like 'character_set_server'; **set used by the whole server
        show variables like 'character_set_database'; **set used by the current database
        show variables like 'collation_database'; **callation used by the current database
 

    CREATE DATABASE Database_name CHARACTER SET charset_name_here COLLATE collation_name_here 

    ** we can also add these features in a database that already exists 
    with :

    ALTER DATABASE database_name CHARACTER SET charset_name COLLATE collation_name_here

    exmple : 

        CREATE DATABASE db_name CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;

    ** To see the current collation and charset in a database use :
        USE db_name;
        SELECT @@character_set_database, @@collation_database;

# EXPORT A DATABASE

        Run the command from terminal :

            mysqldump -u root -p name_of_schema > /url/folder/url_to_file/file.sql


# EXPORT/IMPORT A SINGLE TABLE 

        **Run command 
        **export
        mysqldump -h localhost -u root -p schema_name table_name > tablem_name.sql

        **import ** this only works if the .sql contains an exported table
        mysql -h localhost -u root -p schema_name < tablem_name.sql


# SQL QUERIES

---------------------------------------------------------
DDL
---------------------------------------------------------


# TABLE CREATION SINTAX:

    CREATE TABLE IF NOT EXISTS db_name.table_name(
        column_name column_type column_attribute
    )

    **column_attributes :
        - NOT NULL 
        - UNIQUE
        - DEFAULT default_value
        - AUTO_INCREMENT

    example: 

        CREATE TABLE IF NOT EXISTS employees(
            emp_no int not null auto_increment,
            birth__date date not null,
            first_name varchar(16) not null,
            last_name varchar(16) not null,
            sex enum('M','F') not null,
            hire_date date not null
        );


# ADDING PRIMARY KEY 

    CREATE TABLE IF NOT EXISTS employees(
            emp_no int not null auto_increment,
            birth__date date not null,
            first_name varchar(16) not null,
            last_name varchar(16) not null,
            sex enum('M','F') not null,
            hire_date date not null.
            PRIMARY KEY(emp_no)
    );


# ADDING PRIMARY KEY WITH CONSTRAINT

    **CONTRAINT allow to rename the primary key

    CREATE TABLE IF NOT EXISTS employees(
            emp_no int not null auto_increment,
            birth__date date not null,
            first_name varchar(16) not null,
            last_name varchar(16) not null,
            sex enum('M','F') not null,
            hire_date date not null.
            CONTRAINT PK_employees PRIMARY KEY (emp_no)
    );

    ** A table can have a primary keys made out of several columns

    CREATE TABLE IF NOT EXISTS employees(
            emp_no int not null auto_increment,
            birth__date date not null,
            first_name varchar(16) not null,
            last_name varchar(16) not null,
            sex enum('M','F') not null,
            hire_date date not null.
            CONTRAINT PK_employees PRIMARY KEY (emp_no,first_name,last_name)
    );


# ADDING FOREIGN KEY 

    FOREIGN KEY (table_column) REFERENCES other_table(table_column)

    example:

    CREATE TABLE IF NOT EXISTS employees(
            emp_no int not null auto_increment,
            birth__date date not null,
            first_name varchar(16) not null,
            last_name varchar(16) not null,
            sex enum('M','F') not null,
            hire_date date not null.
            PRIMARY KEY(emp_no),
            FOREIGN KEY (emp_no) REFERENCES departemant(emp_no)
    );


# ADDING FOREIGN KEY WITH CONSTRAINT 

    CREATE TABLE IF NOT EXISTS employees(
            emp_no int not null auto_increment,
            birth__date date not null,
            first_name varchar(16) not null,
            last_name varchar(16) not null,
            sex enum('M','F') not null,
            hire_date date not null.
            PRIMARY KEY(emp_no),
            CONTRAINT FK_emp_no FOREIGN KEY (emp_no) REFERENCES departemant(emp_no)
    );


# ADDING CASCADE CLAUSE 

    **The cascade clause can only be applyed to foreign keys. 
    The idea is that if the reference is modified/deleted this will also affect the current table
    that has the cascade clause specified.
     
    **If the on cascade clause is not used we may run into a table integrity error

    example of clause:

        - ON DELETE CASCADE
        - ON UPDATE CASCADE 
    
    example :

        CREATE TABLE IF NOT EXISTS employees(
            emp_no int not null auto_increment,
            birth__date date not null,
            first_name varchar(16) not null,
            last_name varchar(16) not null,
            sex enum('M','F') not null,
            hire_date date not null.
            PRIMARY KEY(emp_no),
            CONTRANINT FK_emp_no FOREIGN KEY (emp_no) REFERENCES departemant(emp_no)
            ON DELETE CASCADE
    );
    
    **if the reference in departemant is deleted the changes in the table 
    employees will also be afected.


# ADDING PRIMARY KEY WITH ALTER TABLE

    ALTER TABLE employees ADD CONTRAINT PK_employees PRIMARY KEY(emp_no)


# CREATE A TEMPORAL TABLE 

    **a temporal table only exists during a session
    ** create a temporal table and insert into it the data form other table

    CREATE TEMPORARY TABLE table_name select * from other_table_name


# ALTER TABLE (DDL)

    **add,create or mofify columns and data in tables
    **sintaxis:

        ALTER TABLE table_name ddl_command 
    
    commands : 
    
        ** ADD column_name data_type attributes FIRST | AFTER some_column
        ** DROP COLUMN column_name 
        ** MODIFY column_name data_type atributes
        ** CHANGE COLUMN column_name new_column_name atributes

    example :

        ALTER TABLE table_name ADD CONSTRAINT PK_id PRIMARY KEY(id)
    example:
        ALTER TABLE table_name ADD CONSTRAINT FK_name FOREIGN KEY (name) REFERENCES person(name)
    example:
        ALTER TABLE DROP CONSTRAINT FK_someconstraint
    
    example:
        ALTER TABLE table_name MODIFY COLUMN column_name INT auto_increment PRIMARY KEY;


# DROP TABLE (DDL)

    **delete table 
    DROP TABLE table_name 

    **rename table
    RENAME TABLE table_nname TO new_table_name 

    **delete all data in a table
    TRUNCATE TABLE table_name 



# CALCULATED or MATERIALIZED VIEWS/COLUMNS (DDL)

    **It is possible to genereta tables and columns from expresions
    or formulas . These are called calculated columns
    
    PROS:
        > You can use them to create more compact results from large queries
          therefore they can be used to simplify queries .
        > This type of views help to speed up queries if done properly and used 
          with indexes.
        > If used as virtual they do not occupy space in your database
        > If calculations in a query are expensive consider using MATERIALIZED/calculated views
    CONST:
        > UPDATE,DELETE and ALTER operations are slower. Use MATERIALIZED views only for SELECT queries

    **sintaxis:

        column GENERATED ALWAYS AS (expression) VIRTUAL | STORED

    **more sintanix:

    new_column_name [GENERATED ALWAYS] as (expression) 
    [VIRTUAL|STORED] [NOT NULL | NULL] [UNIQUE KEY] | [PRIMARY KEY]
    [COMMENT]

    **VIRTUAL : Any calculation will be virtula and not stored in the database
    **STORED : Column generated from calculation will be stored

    example : 
        ** RANDOM NUMBER FORMULA in MYSQL :
        ** This generates a random number between a and b 
            (RAND()*(a-b+1)+a )

        CREATE TEMPORARY TABLE ProjectCost(
            manager INT not null,
            project INT not null,
            developers INT not null,
            dev_cost INT not null, 
            managerial_cost INT not null,
            estimated_time INT not null,
            total_cost INT GENERATED ALWAYS as ((dev_cost+managerial_cost)*estimated_time) VIRTUAL not null
        )engine = innoDB;

        **Here we are creating a table with manager,project and developer which are data stored in our
        database and generating(calculating) total_cost based on the data of other columns.


------------------------------------------------------------------------------------------------
TRIGGERS 
------------------------------------------------------------------------------------------------


# CREATE A TRIGGER

    **A trigger is a function "triggered" after or before and action is
    executed on a table in a database. 
    ** And action can be an operation like INSERT , UPDATE, DELETE 
    **Triggers are linked to a table.
    **In order to create a trigger you must be a superuser

    **Creating a trigger

    CREATE TRIGGER 
        triger_name trigger_time 
        some_action ON table_name 
        FOR EACH ROW trigger_order function_or_action

     - trigger_time: { BEFORE | AFTER }

     - trigger_event: { INSERT | UPDATE | DELETE }

     - trigger_order: { FOLLOWS | PRECEDES } other_trigger_name ** Only in case you wish
     to chain triggers


    example :

        drop tigger if exists persona_before_update;

        DELIMITER // 
        CREATE TRIGGER persona_before_update 
        BEFORE UPDATE ON personas FOR EACH ROW
        BEGIN
            SET NEW.correo=lower(new.correo);
        END // 
        DELIMITER ; 

        ** This trigger sets correo on 

    example 2:

        drop trigger if exists update_insert_persona ;

        delimiter //
        create trigger update_insert_persona 
        after insert on personas for each row
        begin 
          
            insert into usuarios(nombre,password,idPersona) VALUES 
                (new.nombre,"temporary_table",new.id);
        end // 
        delimiter ;

        **This trigger creates an user for each new personas


# SIGNALS 

    **singnals are like console logs that alow to send messages or alerts
    **They can be used in
        - procedures 
        - functions 
        - if statements 

    **This sintaxis is quiete simple 

    SIGNAL SQLSTATE 'sql_error_code' SET MESSAGE_TEXT = 'some message you want to sent';

    example:

        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'An error occured';
    
    example :

        SIGNAL SQLSTATE '01000' SET MESSAGE_TEXT = 'New user added';

    **01000 are warning class SIGNALS
    **45000 are error class SIGNALS



--------------------------------------------------------------------------------
DML 
-------------------------------------------------------------------------------- 


# BASIC INSERT VALUE INTO TABLE 

    **basic insert operation 
        INSERT PRIORITY INTO table_name (tablefield1,tablefield2) VALUES (value_tablefield1,value_tablefield2);

        PRIORITY : [LOW_PRIORITY | HIGH_PRIORITY | IGNORE]
         - if you use the LOW_PRIORITY modifier, execution of the
          INSERT is delayed until no other clients are 
          reading from the table.
         - ignore errors with the clause IGNORE . INSERT IGNORE INTO table_name
         - HIGH_PRIORITY affects only storage engines that use only table-level
          locking (such as MyISAM, MEMORY, and MERGE).

        example:
            INSERT INTO people (name,surname) VALUES ("Robin","viera");

# INSERT SELECT 

    **allows you to insert values in a table "B" with the result
    of the SELECT of a table "A"

    example:
        INSERT INTO managers (id) 
            SELECT employees.id FROM employees
                WHERE employees.category = "A";

        **here we are inserting values in managers from table 
        employees

# INSERT ON DUPLICATE KEY 

    **launch and insert operation that handles duplicated keys
    example:
        INSERT INTO employees (a,b,c) VALUES (1,2,3)
        ON DUPLICATE KEY UPDATE c = c+1;

    example:
        UPDATE employees SET c=c+1 WHERE a=1; 

    example :
        INSERT INTO employees(a,b,c) VALUES (1,2,3) ON
        DUPLICATE KEY UPDATE  c = VALUES(a) * 2;


# SELECT 

    **extract / select data 

    example :

        SELECT  * FROM table_name WHERE condition ORDER_BY column ASC / DESC 

        **you can use an alias for your table if your table as a very long or complicated name
        SELECT * FROM table_name table_alias WHERE conditions..

    ** usig string methods :
    LEFT : take the specified number of caracter from the field
        LEFT (string,number_of_characters)

    DATE_FORMAT : format a date in certain way 
        DATE_FORMAT (date,format_as_string)

    ROUND : round a number
        ROUND(number,decimals)

    BETWEEN: fetch date in a range of values.
        BETWEEN value_a AND value_b
    
    IS [NOT] NULL : fetches by values that are null or not.

    IN: works as a compact OR operator, returns data that
    matches with the specified values .

        SELECT * FROM table where id in(1,2,4,12,2);
    
        **IN also can be used to cancatenate subqueries :

            SELECT * FROM talbe_name where id in(
                SELECT id from other table where price > 100
            );
       
        Sometimes subqueries can be more efficient than joins.
        It is worth try in which case one is more efficient than 
        the other.

    example : 

        SELECT id,ROUND(income,2) as "income",
        DATE_FORMAT(date,"%d/%m/%Y") as "date",
        LEFT(name,3) as "name" FROM
        bank_data WHERE date between "2008-01-04" AND "2009-01-01"
        ORDER BY income DESC;
    
    example :

        select * from personas
        where id in (1,2,3,4);
    
    example :

        select * from ingresosEgresos
        where idGrupoIngEg in(
	    select idGrupoIngEg where idGrupoIngEg between 3 and 5
        );

    
    example:

        select * from entradaSalidaDinero
        where idPersonas in (
	    select id from personas
	    where nombre in ('JUAN PEREZ GARCIA','ARACELI ORTIZ PINEDO')
        );


# SELECT + GROUP BY + HAVING + ORDER BY 

    sintaxis 

    SELECT *
    FROM table_name
    WHERE condition
    GROUP BY 
    HAVING 
    ORDER BY

    **where is a filter pre-agrupations
    **having is a filter after agrupation
    **The having clause is used to make search conditions 
    for agregation groups made the group by.
    **Having can only be use after group by.


    example :

        select distinct personas.nombre,entradaSalidaDinero.montoIE, entradaSalidaDinero.fecha from
        personas inner join entradaSalidaDinero on (personas.id = entradaSalidaDinero.idPersonas)
        where entradaSalidaDinero.fecha > 2018
        group by personas.nombre,entradaSalidaDinero.montoIE,entradaSalidaDinero.fecha
        having 	max(entradaSalidaDinero.montoIE) > 1500
        order by entradaSalidaDinero.montoIE limit 100;


# WITH ROLLUP

    select personas.nombre,entradaSalidaDinero.montoIE,sum(entradaSalidaDinero.montoIE) as 'total' from
    personas inner join entradaSalidaDinero on (personas.id = entradaSalidaDinero.idPersonas)
    where entradaSalidaDinero.fecha > 2018
    group by personas.nombre,entradaSalidaDinero.montoIE with rollup
    having 	max(entradaSalidaDinero.montoIE) > 1500;

    **Roll up creates a summary of the agragation functions 
    used in the select. In this case there is only one agragation function :
    sum(entradaSalidaDinero.montoIE) as 'total' so rollup shows 
    a summary of this agregation

# OPERATOR REGEXP / LIKE

    This operators are used for search patterns and regular expresions .
    . The main difference between like and regexp is that LIKE is not case 
    sensitive.

    example with LIKE :

        %a : all string that end with "a"
        a% : all strings that start with "a"
        %a% : all string that contain

    example  with regexp:
        **it uses the same sintaxis than convensional regular expresions

        'some' : string contains the word/phrase 'some'
        '^ala' : string starts with word/phrase 'ala'
        'for$' : string ends with the word/phrase 'for'
        'sn|es|ps' : array of matches .Finds string that contains 'sn' or 'es' or 'ps'.

    example :

        SELECT * FROM Employees.Employees where name like 'qui%';
    
    example: 

        SELECT * FROM Employees.Employees where 

    example:

        SELECT * FROM Employees.Employees where name like '%ta';

    example:

        SELECT * FROM Employees.Employees where name like '%lu%';

    example with regexp:

        **get values where name contains 'lup' and suername contains 'min'

        SELECT * FROM Employees.Employees where 
        name regexp 'lup' and surname regexp 'min';


# PAGING IN MYSQL AND THE LIMIT OPERATOR

    **The limit operator accepts 2 arguments. 

        - the first argument determines or limits the number of results.

        example : 

            SELECT * FROM Employees.Employees limit 10 ;

        - If used the second argument , the first argument becomes an index 
        and the second argument specifies how many result will optain from that 
        index.

        example :

            SELECT * FROM Employees.Employees limit 4,10 ;

            **The fetch of information will start at index 4 in our table 
            and extract 10 results from index 4 --> from index 4 to 14.
            A total of 10 items.

            **This is the main method to make paging.


# DML INNER JOIN 

    **A join combines columns from 2 or more tables in a single dataset 
    **Tables are ususaly connected by their PRIMARY - FOREIGN KEYS relations
    
    sintaxis :

        SELECT seletct_list 
        FROM table1 
        [INNER] JOIN table2 ON conditions
        [INNER] JOIN table3 ON conditions 

        the INNER keys selects record that match in both tables

    example 2 tables  join:

        SELECT personas.id,personas.nombre as 'cliente',entradaSalidaDinero.montoIE as 'transaccion' FROM personas
        INNER JOIN entradaSalidaDinero ON 
        personas.id = entradaSalidaDinero.idPersonas AND 
        montoIE between 3900 and 4000
        ORDER BY entradaSalidaDinero.montoIE DESC ;

    example 3 tables join:

        select 
        personas.id,personas.nombre,
        entradaSalidaDinero.montoIE as 'cantidad' , 
        ingresosEgresos.idTipoIngEg as 'movimiento',
        ingresosEgresos.idGrupoIngEg as 'grupo movimientos'
        from personas
        inner join entradaSalidaDinero on  personas.id = entradaSalidaDinero.idPersonas
        inner join ingresosEgresos on entradaSalidaDinero.idIngresosEgresos = ingresosEgresos.id and ingresosEgresos.idTipoIngEg = 1;

# USING TABLE ALIASES WITH JOIN

    SELECT * 
    FORM TABLE table_1 t1 
    [INNER] JOIN table2 t2 ON t1.id = t2.id
    [INNER] JOIN table3 t3 ON t2.id = t3.id

    ** notice how once you create the aliases t1,t2,t3 

# EXTACTING DATA FORM 2 DATABASES :

    sintaxis : 

        SELECT * FROM table_1 
        INNER JOIN database.table.field alias ON  alias.id = table1.id


# LEFT JOIN / RIGHT JOIN

    example : 

        SELECT client,chash,date
        FROM clientes JOIN facturas ON clientes.id = facturas.id 

        ** left join returns the items from the left table 
        that are found in the right table. 

        **If the left table id exists in the right table 
        return client,chash,date that correspond to that id .

        **If no item from the left if found on the right then the 
        search returns null  for client,chash,date

        **the RIGHT JOIN works exactly the same way except from the left ---> right 

        (left table)        (right table)
        clientes     JOIN   facturas

        left join
        **clientes <---- facturas

        right join
        **clinetes ----> facturas 

        ** RIGHT/LEFT join is usefull to know what items from one table exists in other time 
        or to if items of one databases exists in the table of other database.


# COMPACT JOIN INSTRUCTIONS WITH 'USING' AND 'NATURAL'

    ** the word using allows us to make a join by fields
    ** 'using' replaces the word ON and the prefix of the tables
    effectively replacing people.id / titles.id 
    
    **** using only works if the fields used in the join are iqual***
    *** therefore using only works because both fields are called 'id' ****

    SELECT name,surname FROM 
    people  JOIN titles using(id)


# IMPLICIT INNER JOIN 

    Though the query only uses WHERE , the join union is implicit 
    therefore producing the same result as an inner join.
    Perfomance between inner join and implicit inner join may vary.

    sintaxis : 

        select table1.field,table2.field,table3.field 
        from talbe1,table2,table3 
        where 
        table1.field = table2.field
        and
        table2.field = table3.field

# UNION 

    **An union combines the result of several select queries.
    **An union combines the values of one table into another table
    eliminating duplicates. Unions eliminate duplicates
    **Each result returns the same number of columns
    **Tables to be unionized must have the same type of columns.
    
    **select statements must have the same number of fields :

    select name,surname,phone from users 
    union
    select name,surname,id from clients
    order by name;
    
    **This instruction will join the 2 tables by name
    eliminating duplicated fields.

    example :

        select statament_1
        UNION [ALL] 
        select statament_2
        UNION [All]
        select statament_3
        ORDER BY statament

# SUBQUERIES 

    **CLAUSES that allow us to make subqueries :

        - WHERE 
        - HAVING 
        - FROM 
        - SELECT 

    # SCALAR SUBQUERIES 
        example with select/where : 

            select * ,(select avg(montoIE) from entradaSalidaDinero) as 'promedio' 
            from entradaSalidaDinero
            WHERE montoIE > (
                select avg(montoIE) from entradaSalidaDinero
                );

        example with variables :

            SET @promedio:= (select avg(montoIE) from entradaSalidaDinero);
            select * , @promedio as 'promedio'
            from entradaSalidaDinero
            where montoIE > (@promedio);
        
    # LIST SUBQUERIES 


        1)example of an inner join :

           select entradaSalidaDinero.id,entradaSalidaDinero.montoIE from entradaSalidaDinero
           inner join personas ON (entradaSalidaDinero.idPersonas = personas.id)
           where personas.nombre like '%JUAN%'; 
        
            ** the result will be the fields of entradaSalidaDinero where idPersonas
            exists in personas + the fields of personas we may want to show.

        2)now the alternative using a subquery : 

            select * from entradaSalidaDinero
            where entradaSalidaDinero.idPersonas 
            in
            (
                select id from personas where personas.nombre like '%JUAN%'
            );

            ** the result will be only the fields of entradaSalidaDinero where idPersonas
            exists in personas
            

# ALL CLAUSE 

    **The ALL clause is use to compare to all the values resultant from 
    a query .
    **The ALL clause works as a compact AND 

    example:

        X > ALL(2,4,1,6)

        **This is the same that if X > 2 AND  X > 4 AND x > 1  AND x > 6 ...etc 
        **Compared to IN that is like a compact OR
        **If the subquery returns nothing then all is True by default

    example :

        **MontoIE means cash in this case
        ** In this queries we get all personas that 
        have montoIE > than all personas that have less or equal
        to 4000 monotIE

        select idPersonas from 
		entradaSalidaDinero where montoIE > all(
			select montoIE from entradaSalidaDinero where montoIE <= 4000
		) 

# ANY/SOME CLAUSE 

    **any or some is in practical terms similar for exists but used in 
    subqueries 

    example :

        **select any personas that is different than idPersonas = 2

        select id,montoIE,idPersonas from entradaSalidaDinero
        where montoIE  <> any (
	    select montoIE from entradaSalidaDinero where idPersonas = 2
        );

        **or 
        **select any personas where montoid > idPersonas =2 motnoIE

        select id,montoIE,idPersonas from entradaSalidaDinero
        where montoIE > any(
        select montoIE from entradaSalidaDinero where idPersonas = 2
        );


# COORELATED SUBQUERIES 

    **A coorelated subquery is like a nested for loop 
    ** A coorelated subquery consist in a "father query" and a "subquery"
    ** for each item in the father query the subquery will search in 
    all the elements of the father 
    ** A coorelated subquery often implies a table making a reference to itself

    structure :
        **notice is required to use an alias for the father query 

        select all from table table_alias where condition (
                select from  table where field condition table_alias.field
            )
    
    example :

        ** select the montoIE value from each idPersonas that is
        bigger than the avg montoIE of that same idPersonas

        select * from entradaSalidaDinero esd
        where montoIE > (
	        select avg(montoIE) from entradaSalidaDinero 
            where idPersonas = esd.idPersonas group by idPersonas
        );

    
    example 2 : **this example allows us to see the avg 

        select *,( select avg(montoIE ) from entradaSalidaDinero where idPersonas = esd.idPersonas
        ) as 'promedio'  from entradaSalidaDinero esd 
        where montoIE > (
            select avg(montoIE ) from entradaSalidaDinero
            where idPersonas = esd.idPersonas
        ) order by idPersonas


    example 3 : select all personas that do not have a user in the 
    table usuarios .

        select * from personas pe
        where id not in ( 
	        select idPersona from usuarios where 
		    pe.id = idPersona
        );
    
    example 4 like example 3 but using exists:

        select * from personas pe
            where not exists ( 
	        select idPersona from usuarios where pe.id = idPersona
        );
    
    example 5 select all from personas that do not exists in pendientes 
    **pendientes as 2 foreign keys to id personas 

    select * from personas pe 
        where not exists ( 
	    select idPersonaQueAsigno,idPersonaAsignado from pendientes where
        pe.id in(idPersonaQueAsigno,idPersonaAsignado)
    );


    example 6 : 

        select * from personas pe 
        where not exists ( 
            select * from entradaSalidaDinero where
            pe.id = idPersonas
        );

# FROM SUBQUERIES

    **The basic idea is create a query that becomes a 
    virtual table and from that virtual table make 
    select from like you would do from any other table 
    **The main difference is that 
    the virtual table requires an alias, in this cases "subquery"
    otherwise it wont work

    select * from

            (

            select 
                entradaSalidaDinero.idPersonas,
                personas.nombre as 'nombre',
                sum(entradaSalidaDinero.montoIE) as 'suma_total'
            from personas 
            inner join entradaSalidaDinero on 
                (personas.id = entradaSalidaDinero.idPersonas) 
            group by personas.id

            ) as subquery
    inner join usuarios on (usuarios.idPersona = subquery.idPersonas)
    where idPersonas in (1,2,3);


# CTE (COMMON TABLE EXPRESSIONS)

    **CTE are very similar to subqueries
    **A CTE is a select query that creates more resultsets 
    that can be used the following queries.

    sintaxis:

        **subquery can be a select/insert/update/delete

        WITH cte_name as (subquery),
        cte2_name as (subquery2),
        cte3_name as (subquery3)

        sql_statments

    example:

    **create the previous from subquery only using CTEs 

    with aux_subquery as (
            
             select 
                entradaSalidaDinero.idPersonas,
                personas.nombre as 'nombre',
                sum(entradaSalidaDinero.montoIE) as 'suma_total'
            from personas 
            inner join entradaSalidaDinero on 
                (personas.id = entradaSalidaDinero.idPersonas) 
            group by personas.id
    )

    select * from aux_subquery
    inner join usuarios on (usuarios.idPersona = aux_subquery.idPersonas)
    where idPersonas in (1,2,3);

    **basically CTE allow us to execute queries and 
    store them in variables


# DML sentences  INSERT / UPDATE /DELETE

    # ** copy a table into another table 
        create table new_table as 
        select * from origin_table;

    # **copy a table without data 
        create table new_table as 
        select * from origin_table 
        where id=-1

    ***Copied tables DO NOT inherit primary keys , foreign keys , auto_increment etc 

    **since id -1 doesnt exists the copies table will be empty 

    # INSERT 
        ** allows you to add new entries in a table 

    sintaxis : 

        INSERT INTO table_name (table_field1,table_field2)
        VALUES (value1,value2)


    # UPDATE 

        UPDATE table_name SET 
        column_name = expresion1,
        column_name2 = expresion2
        ...
        WHERE condition

    example:

        update entradaSalidaDinero SET
        montoIE=(montoIE+((montoIE*10)/100))
        where fecha like '%-03-%' AND id <> 0;

        **You have to reference a primary key in your update clause
        as a safety meassure. In this case id is PK of this table

    example :

        update personas 
        set nombre = (
            select nombre from tempPersonas where personas.id = tempPersonas.id
            )
        where personas.id = (
            select id from tempPersonas where personas.id = tempPersonas.id
        )
        and id != 0;

    # DELETE 

    DELETE from table where conditions;

    example :

        DELETE from  usuarios us
        where exists (
                select * from personas where us.idPersona = personas.id
            ) and id != 0

     **You have to reference a primary key in your delete clause
        as a safety meassure. In this case id is PK of this table


# AGREGATION FUCNTIONS 

    **get the maximun ,minumun ,avg of a list 
    **The list must output one single result 

    example :

        select monotIE from entradaSalidaDinero;

        **A list with more thatn one column wont work 

    AGREAGTION KEY WORDS :

        **ALL is implicit by default. It uses all the elements of the list
        **DISTINCT selects the elements from the list that do not repeat

        AVG [ALL | DISTINCT] expression  
        SUM [ALL | DISTINCT] expression
        MAX [ALL | DISTINCT] expression
        MIN [ALL | DISTINCT] expression
        COUNT [ALL | DISTINCT] expression

    example :

        select 
        count(*) as 'elementos', 
        max(montoIE) as 'max_valor', 
        min(montoIE) as 'min_valor', 
        round(avg(montoIE),2) as 'avg',
        round(sum(montoIE),2) as 'total' 
        from entradaSalidaDinero where
        fecha > 2018;


# OPERATOR OVER

    **over functions or window fuctions can be used with any agregation function
    **over allows to create additional columns as summary of the result of agregation functions
    like sum,count,max,avg etc 
    **Allows to use agregation functions without group by.

    example :

        select idPersonas,fecha,montoIE,sum(montoIE) over() as 'total',count(*) over() as 'registros' 
        from entradaSalidaDinero
        where year(fecha)=2018 and month(fecha)=1;


    **If we didnt use the function over the previous query would have to use group by :
    **example :

        select idPersonas,fecha,montoIE,sum(montoIE) as 'total',count(*) as 'registros' 
        from entradaSalidaDinero
        where year(fecha)=2018 and month(fecha)=1
        group by montoIE,fecha,idPersonas;


    **You can make subdivisions or partitions making groups of data based on on parameter.
    **example : We want to make partitions of montoIE based on the id
    
    idPersonas,
    fecha,
    montoIE,
    sum(montoIE) over() as 'total',
    count(idPersonas) over() as 'total personas',
    count(idPersonas) over(partition by idPersonas) as 'total specifi id'
    from entradaSalidaDinero
    where year(fecha)=2018 and month(fecha)=1;

    **In this with 'count(idPersonas) over(partition by idPersonas)' we are counting 
    how many ids are from each id .


    **example : 
    **partitions with order by 

    select 
        idPersonas,
        fecha,
        montoIE,
        sum(montoIE) over(partition by idPersonas order by montoIE desc) as 'total por persona',
        count(idPersonas) over() as 'total personas',
        count(idPersonas) over(partition by idPersonas) as 'total specifi id'
        from entradaSalidaDinero
    where year(fecha)=2018 and month(fecha)=1;


    **example::
    **partitions with inner join

    select personas.nombre,ingresosEgresos.descripcion,entradaSalidaDinero.montoIE,
    sum(entradaSalidaDinero.montoIE) over() as 'monto total',
    count(personas.id) over() as 'registros total',
    count(personas.id) over(partition by personas.id) as 'registros por persona',
    sum(entradaSalidaDinero.montoIE) over(partition by personas.nombre order by entradaSalidaDinero.montoIE) as 'monto por persona'
    from entradaSalidaDinero 
    inner join personas on entradaSalidaDinero.idPersonas = personas.id
    inner join ingresosEgresos on entradaSalidaDinero.idIngresosEgresos = ingresosEgresos.id
    where year(entradaSalidaDinero.fecha)=2018 and month(entradaSalidaDinero.fecha)=1;

# CREATING VIEWS 

    VIEW vs TEMPORARY TABLE 

        - A VIEW is persistent accross sessions.
        - A TEMPORARY TABLE is deleted after the session is over.
        - A view requires more processing since its run each time its called.
        - A temporary table stores the result of the query that creates it.
        

    sintaxix :

        CREATE VIEW personas_view as SELECT QUERY
    
    example :

    create view personas_montoIE as 
        SELECT 
        personas.id,
        personas.nombre,
        entradaSalidaDinero.montoIE,
        sum(entradaSalidaDinero.montoIE) over(partition by personas.nombre) as "total",
        avg(entradaSalidaDinero.montoIE) over(partition by personas.nombre) as "avg",
        max(entradaSalidaDinero.montoIE) over(partition by personas.nombre) as "max",
        min(entradaSalidaDinero.montoIE) over(partition by personas.nombre) as "min"
        from personas inner join entradaSalidaDinero on entradaSalidaDinero.idPersonas = personas.id;

        **select query execution time 0.0096 sec
    
    # delete view if exists view_name


----------------------------------------------------------------------------------
STORED PROCEDURES
----------------------------------------------------------------------------------

    **A stored procedure is just a function in MYSQL 
    **Stored procedure are precompliled executable code.
    **Queries need to be compiled and then executed.
    **Therefore stored procedures are faster than queries.

    **Stored procedures use can use the following logic 

    IF | ELSEIF  | ELSE 
    CASE | WHEN | ELSE 
    WHILE | DO LOOP
    REPEAT | UNTIL | END REPEAT 
    DECLARE CURSOR FOR 
    DECLARE | HANDLER

    sintaxis :

        **We are  setting as delimiter of
        our procedure the character // 

        DELIMITER //
        CREATE PROCEDURE procedure_name()
        BEGIN 
            SELECT QUERY
        END//
        DELIMITER ;

        **After the procedure is ended we reset the delimiter character back to ;
        **This is a void procedure --> procedure_name()
        ** is a function that doesnt use parameters

        example :

            delimiter //
            CREATE procedure hello_world()
            BEGIN 
                SELECT 'Hello world' as hello;
            END//
            delimiter ; 

         execute / call stored procedure :

            call hello_world();


    # Stored procedures with variables.
        **The key word declare creates varibles.
        **The key workd INTO assigns expresion result to variable

    DELIMITER //
    CREATE PROCEDURE items()
    BEGIN 

        DECLARE n_items int;

        SELECT COUNT(*) INTO n_items
        FROM usuarios ;

        SELECT n_items as 'usuarios';

    END//
    DELIMITER ;

    call items();


    # PROCUDURES WITH PARAMETERS 

    ** the key word in are paremeters with pass to the procedure
    ** the key word out indicated the values the procedure returns

    DELIMITER // 
    CREATE PROCEDURE procedure_name(in p_nombre varchar(50),out nombre varchar(50),out fecha date,out monto decimal(6,2))
    BEGIN 

        SELECT personas.nombre,entradaSalidaDinero.montoIE,entradaSalidaDinero.fecha 
        from personas inner join entradaSalidaDinero ON personas.id = entradaSalidaDinero.idPersonas
        WHERE personas.nombre LIKE '%p_nombre%';
    
    END//
    DELIMITER ;

    # call procedure with parameters
    **the @ catchas return values

	drop procedure if exists procedure_name;

    DELIMITER // 
    CREATE PROCEDURE procedure_name(in i_id varchar(50),out nombre varchar(50),out correo varchar(50),out o_id int)
    BEGIN 
		declare result_id int;
        
        SELECT personas.id into result_id
        from BD_Pendientes.personas
        WHERE personas.id = i_id;
        
        SELECT personas.nombre into nombre
        from BD_Pendientes.personas
        WHERE personas.id = i_id;
        
        SELECT personas.correo into correo
        from BD_Pendientes.personas
        WHERE personas.id = i_id;
        
        SELECT personas.id into o_id
        from BD_Pendientes.personas
        WHERE personas.id = i_id;
        
		if result_id is null then
			set nombre="Not found";
            set correo="Not found";
            set o_id=0;
		end if;
    END//
    DELIMITER ;

    call procedure_name(-1,@nombre,@correo,@o_id);
    select @nombre,@correo,@o_id;


        **Procedures cannot return tables , they can return single values in their
        return variables 



    # delete/drop procedure 

        drop procedure if exists procedure_name;


# CASE CLAUSE

    **case is similar to if else

    sintaxis : 

        CASE 

            when conditions then 
                do something;
            when conditions then
                do something;
            .
            .
            .
            else
                do something if no condition match;
        END CASE;

    example:

        DELIMITER //    
        create procedure get_pendiente(in id_pendiente int,out nombre_pendientes varchar(50),out total_pendientes int,out message varchar(100))
        BEGIN

            select personas.nombre into nombre_pendientes  from personas where id_pendiente = personas.id;
            select count(*) into total_pendientes
            from pendientes
            INNER JOIN personas on personas.id = pendientes.idPersonaAsignado
            WHERE personas.id = id_pendiente or
            personas.id = id_pendiente;
            
            case 
                when (total_pendientes>0 and total_pendientes<50) then
                    set message="YOU HAVE SOME TASKS";
                when (total_pendientes>50) then
                    set nombre_pendientes = @nombre_pendientes;
                    set total_pendientes = @total;
                    set message="YOU HAVE MANY TASKS !";
                else
                    set nombre_pendientes = "NOT FOUND";
                    set	message="NOT FOUND";
            end case;
                    
                    
        END//
        DELIMITER ;
            

        call get_pendiente(1,@nombre_pendientes,@total_pendientes,@message);
        select @nombre_pendientes,@total_pendientes,@message;


# WHILE CLAUSE

    **while is used to create loops inside stored procedures 

    drop procedure if exists loop_while;

        DELIMITER // 
        CREATE PROCEDURE loop_while(out result varchar(50))
        BEGIN
            declare counter int default 0 ;
            declare c_limit int default 100;
            declare s varchar(50) default "";

            while counter < c_limit do 
                set counter=counter+1;
            end while;

            set s=concat(s,"count =",counter,"|");
            select  s into result;
        END // 
        DELIMITER ;

    call loop_while(@result);
    select @result;


-----------------------------------------------------------------------------------------------
CURSORS
-----------------------------------------------------------------------------------------------


    PROS
    **Cursors are used inside stored procedures
    **Cursors allow to retrieve information from tables row by row 
    **Cursors can be faster than while loops but more verbose
    **Using cursors allow cuncurrency
    CONS 
    **They exists in stored procedures the they occupy memory 
    **They use more bandwith in the server 
    **Using cursor repeatedly can reduce the speed of the server

    DROP PROCEDURE IF EXISTS CURSORES;
    DELIMITER //
    CREATE PROCEDURE CURSORES(out result int)
    BEGIN
        -- create variables
        DECLARE id_persona_var int;
        DECLARE telefono_var varchar(30);
        DECLARE row_not_found tinyint default false;
        DECLARE update_count int default 0;
        
        -- declaring cursor 
        -- asing cursor to columns
        DECLARE id_persona_cursor CURSOR for
        SELECT id,telefono from personas
        where correo like '%hotmail%';
        
        -- declare error handling
        -- This handler will set row_not_found to True when the cursor arrives to
        -- the end of the table
        DECLARE continue handler for not found set row_not_found = true;
        
        -- open cursor 
        open id_persona_cursor;
        while row_not_found = false do
            fetch id_persona_cursor into id_persona_var,telefono_var;
            if length(telefono_var) > 0 then
                update BD_Pendientes.pendientes set pendientes.observaciones=telefono_var
                where pendientes.idPersonaAsignado=id_persona_var;
            else	
                update BD_Pendientes.pendientes set pendientes.observaciones="SOLICITAR TELEFONO"
                where pendientes.idPersonaAsignado=id_persona_var;
                set update_count = update_count+1;
            end if;
        end while;
        -- closing cursor
        close id_persona_cursor;
        -- returning results
        select update_count into result;
    END//
    DELIMITER ;


    call CURSORES(@result);
    select @result


# STORED FUNCTIONS 

    Stored function :
        - can return only one value 
        - cannot execute intructions update ,delete , insert 
    Stored procedures :
        - can return many values 
        - can executer insert ,update ,delete 


    sintaxis:

        DELIMITER // 
            create function function_name(id_ingreso int) returns return_type
            READS SQL DATA
            DETERMINISTIC
            BEGIN
                <function logic here>
            END//
        DELIMITER ; 

        **call the function 

        select statament,function_name() from table;

    example :

    drop function if exists function_ingresos_egresos;

    DELIMITER // 
    create function function_ingresos_egresos(id_ingreso int) returns decimal(8,2)
    READS SQL DATA
    DETERMINISTIC
    begin
        declare sumatoria decimal(8,2);
        
        select sum(montoIE) into sumatoria from entradaSalidaDinero where 
        idIngresosEgresos=id_ingreso;
        if sumatoria > 0 then 
            return sumatoria;
        else 
            return 0;
        end if;
        
    end//
    DELIMITER ; 

    select id,descripcion,function_ingresos_egresos(id) from ingresosEgresos;
--------------------------------------------------------------------------------------
OPRIMIZATION
--------------------------------------------------------------------------------------

# INDEXES / OPTIMIZATION

    **indexes are used to find specific column values quickly
    ** without and index mysql must begin with the first row and go 
    through the entire table to find relevant rows.
    ** If the table has an index mysql can determine the position to search in the middle
    of the data without having to look at all the data

    Indexes allow to :

        * To find the rows matching a WHERE clause quickly.
        * All primary keys have and associate index by default.

    FOREIGN KEY OPTIMIZATION 

        - IF your table has many columns and the queries have many different combinations
        it may be more efficient to split this table into smaller tables each with 
        a few columns with the least frequently used data.

        - This way each table can have its own primary key for data lookup

# CREATING COLUMN INDEXES prefix 

    **In a string column, a column that uses varchar type 
    you can create an index to the first N characters of the values of column 
    so when a data lookup is done is not nescessary to compare each char of the string

    example :

        CREATE TABLE test (
            name varchar(50) ,
            index(name(10))
        )

        ** This will create an index to the first 10 characters of name.

# MUTIPLE COLUMNS INDEX 

    **Mysql can index up to 16 columns together.
    **Mysql can use multiple columns indexes fo queries that test all the columns
    in the index .
    **A multiple-column index can be considered a sorted array.

    example :

        CREATE TABLE test (
            id         INT NOT NULL,
            last_name  CHAR(30) NOT NULL,
            first_name CHAR(30) NOT NULL,
            PRIMARY KEY (id),
            INDEX name (last_name,first_name)
        );

        **queries that aim at last_name and first_name will run faster.

        **also :

            ALTER TABLE ADD INDEX index_name(columns)

# CHECK OPTIMIZATION WITH CLAUSE EXPLAIN

    **The EXPLAIN statement provides information about how mysql processes 
    a stament giving you info on how your indexes are being used.

    **With the help of EXPLAIN, you can see where you should add indexes 
    to tables so that the statement executes faster by using indexes to find rows.


    example:

         EXPLAIN select * from(
            select 
                entradaSalidaDinero.idPersonas,
                personas.nombre as 'nombre',
                sum(entradaSalidaDinero.montoIE) as 'suma_total'
            from personas 
            inner join entradaSalidaDinero on 
                (personas.id = entradaSalidaDinero.idPersonas) 
            group by personas.id

            ) as subquery
            inner join usuarios on (usuarios.idPersona = subquery.idPersonas)
            where idPersonas in (1,2,3);

    ** This outputs the following data :

    '1', 'PRIMARY', 'usuarios', NULL, 'ALL', 'FK_idUsuariosPersonas', NULL, NULL, NULL, '1', '100.00', NULL
    '1', 'PRIMARY', '<derived2>', NULL, 'ref', '<auto_key0>', '<auto_key0>', '4', 'BD_Pendientes.usuarios.idPersona', '10', '100.00', NULL
    '2', 'DERIVED', 'personas', NULL, 'index', 'PRIMARY', 'PRIMARY', '4', NULL, '11', '100.00', NULL
    '2', 'DERIVED', 'entradaSalidaDinero', NULL, 'ref', 'FK_idPersonas', 'FK_idPersonas', '4', 'BD_Pendientes.personas.id', '45', '100.00', NULL

    ** We can see there are 2 foreing keys one of then referencing a primary key 
    ** This help us to notice we probably should add an index to this 2 foreign keys
    to optimize the data look up


-------------------------------------------------------------------------------------------------

TRANSACTIONS

-------------------------------------------------------------------------------------------------

    **By default mysql works in autocommit mode .
    This is means all queries are execute once the query is valid.

    **Transactions allow us to handle errors during execution time of query 
    ** the commit key word stores the result of the opration commiting the changes.
    ** the rollback key word aborts any change .


    sintaxis :

    delimiter //
    create procedure make_transaction()
    begin
        **flag used for the transaction 
            declare sql_error tinyint default false; 
        
        **Create a handler to set the flag to true if an error happends
            declare continue handler for sqlexception set sql_error = true
        **begin the transaction
            start  transaction;

            **SQL statement here (insert,update,delete,create)

        if sql_error = false then 
            commit; **transaction executed
        else 
            rollback; **transaction aborted
        endif
    end//
    delimiter;

    call make_transaction();

# HOW TO USE MYSQL WITH DOCKER

    *open mysql shell in the docker container
        -   docker exec -it <container_name> bash
    *authenticate
        - mysql -u root -p 
    *introduce password 
    *select a database
    USE <database_name>

** for additional docuemtnation about instructions and commands consult mysql documentation
    in w3shcool.com



